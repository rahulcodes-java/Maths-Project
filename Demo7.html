<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Pigeonhole Principle Hash Collision Demo</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .hash-slot-list::-webkit-scrollbar {
            width: 4px;
        }
        .hash-slot-list::-webkit-scrollbar-thumb {
            background-color: #4f46e5;
            border-radius: 2px;
        }
        .hash-slot-list::-webkit-scrollbar-track {
            background: #1f2937;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a;
            color: #f3f4f6;
        }
    </style>
    <script>
        // Configuration constants
        const HASH_SPACE_SIZE = 100; // Number of pigeonholes (hash slots)
        const NUM_INPUTS = 150;      // Number of pigeons (inputs)
        const INPUT_LENGTH = 8;      // Length of each input string
        const DELAY_MS = 50;         // Delay for animation in milliseconds

        // Data structure for the hash table (pigeonholes), each slot holds a list (chaining)
        let hashTable = new Array(HASH_SPACE_SIZE).fill(0).map(() => []);

        let totalCollisions = 0;
        let inputsProcessed = 0;
        let animationActive = false;

        // Variables for resolution phase
        let resolutionActiveSlots = [];
        let currentResolutionSlotIndex = 0;

        // Simple non-cryptographic hash implementation (sum of char codes mod slot count)
        function simpleHash(inputString, spaceSize) {
            let hashValue = 0;
            for (let i = 0; i < inputString.length; i++) {
                hashValue += inputString.charCodeAt(i);
            }
            return hashValue % spaceSize;
        }

        // Generate a random alphanumeric string of given length
        function generateRandomInput(length) {
            const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return result;
        }

        // Initialize the hash grid with empty slots
        function initializeGrid() {
            const gridContainer = document.getElementById('hashGrid');
            gridContainer.innerHTML = '';
            for (let i = 0; i < HASH_SPACE_SIZE; i++) {
                const slot = document.createElement('div');
                slot.id = `slot-${i}`;
                slot.className =
                    'p-1 h-20 bg-gray-800 rounded-lg shadow-inner flex flex-col overflow-hidden transition-all duration-300 border border-gray-700';
                slot.innerHTML = `
                    <div class="text-xs font-mono text-gray-400">#${i} (0)</div>
                    <ul class="hash-slot-list text-xs font-mono mt-1 space-y-0.5 overflow-y-auto flex-grow"></ul>
                `;
                gridContainer.appendChild(slot);
            }
        }

        // Update the status text (inputs processed, unique slots used, collisions)
        function updateStatus() {
            const uniqueSlots = hashTable.filter(arr => arr.length > 0).length;
            document.getElementById('statusText').textContent =
                `Processed: ${inputsProcessed}/${NUM_INPUTS} | Unique Slots Used: ${uniqueSlots} | Collisions: ${totalCollisions}`;
        }

        // Update a single hash slot visually with new input and collision highlight
        function updateSlotUI(hashIndex, newInput, isCollision) {
            const slot = document.getElementById(`slot-${hashIndex}`);
            const list = slot.querySelector('ul');

            // Add new input to the slot's list with animation
            const listItem = document.createElement('li');
            listItem.className = 'bg-indigo-700 text-white px-1 rounded truncate opacity-0 transform translate-y-2 transition-all duration-300';
            listItem.textContent = newInput;
            list.appendChild(listItem);

            setTimeout(() => {
                listItem.classList.remove('opacity-0', 'translate-y-2');
            }, 10);

            // Update slot count display
            slot.querySelector('div').textContent = `#${hashIndex} (${hashTable[hashIndex].length})`;

            if (isCollision) {
                // Collision highlight: flash red then settle on indigo background
                slot.classList.add('bg-red-700', 'border-red-500', 'ring-4', 'ring-red-500/50');
                setTimeout(() => {
                    slot.classList.remove('bg-red-700', 'border-red-500', 'ring-4', 'ring-red-500/50');
                    slot.classList.add('bg-indigo-800');
                }, DELAY_MS * 2);
            } else {
                // Successful placement highlight: flash green then reset background
                slot.classList.add('bg-green-700', 'border-green-500', 'ring-4', 'ring-green-500/50');
                setTimeout(() => {
                    slot.classList.remove('bg-green-700', 'border-green-500', 'ring-4', 'ring-green-500/50');
                    slot.classList.add('bg-gray-800');
                }, DELAY_MS * 2);
            }

            // Maintain indigo background on slots with multiple items (chaining)
            if (hashTable[hashIndex].length > 1) {
                slot.classList.remove('bg-gray-800');
                slot.classList.add('bg-indigo-800');
            }
        }

        // Main animation loop: generate inputs, hash, place in table, update UI incrementally
        async function animateHashing() {
            animationActive = true;
            document.getElementById('startButton').disabled = true;
            document.getElementById('resolutionButton').disabled = true;
            inputsProcessed = 0;
            totalCollisions = 0;
            hashTable = new Array(HASH_SPACE_SIZE).fill(0).map(() => []);
            initializeGrid();
            updateStatus();

            for (let i = 0; i < NUM_INPUTS; i++) {
                if (!animationActive) break;

                const inputData = generateRandomInput(INPUT_LENGTH);
                const hashOutput = simpleHash(inputData, HASH_SPACE_SIZE);

                const isCollision = hashTable[hashOutput].length > 0;
                if (isCollision) totalCollisions++;
                hashTable[hashOutput].push(inputData);
                inputsProcessed++;

                updateSlotUI(hashOutput, inputData, isCollision);
                updateStatus();

                // Delay for animation effect
                await new Promise(resolve => setTimeout(resolve, DELAY_MS));
            }

            document.getElementById('statusTitle').textContent = "DEMONSTRATION COMPLETE!";
            document.getElementById('statusTitle').classList.add('text-yellow-400');
            document.getElementById('startButton').disabled = false;
            document.getElementById('resolutionButton').disabled = false;
            animationActive = false;
        }

        // Resolution animation: empty the chains one by one
        async function animateResolution() {
            document.getElementById('resolutionButton').disabled = true;
            document.getElementById('startButton').disabled = true;
            document.getElementById('statusTitle').textContent = "Resolution Phase Running...";
            document.getElementById('statusTitle').classList.remove('text-yellow-400');
            
            resolutionActiveSlots = hashTable.map((chain, idx) => ({ idx, chain })).filter(slot => slot.chain.length > 0);
            
            for (const slotData of resolutionActiveSlots) {
                while (slotData.chain.length > 0) {
                    // Remove one item
                    slotData.chain.shift();
                    hashTable[slotData.idx] = slotData.chain;
                    redrawSlotContent(slotData.idx);
                    updateStatus();
                    document.getElementById('statusText').textContent = `Resolving Hash #${slotData.idx}, remaining items: ${slotData.chain.length}`;
                    await new Promise(resolve => setTimeout(resolve, DELAY_MS));
                }
                // Mark the slot background back to empty style after chain clears
                const slot = document.getElementById(`slot-${slotData.idx}`);
                slot.classList.remove('bg-indigo-800');
                slot.classList.add('bg-gray-800');
            }
            document.getElementById('statusTitle').textContent = "Resolution Phase Complete!";
            document.getElementById('startButton').disabled = false;
        }

        // Redraw slot content list & count after modification during resolution
        function redrawSlotContent(index) {
            const slot = document.getElementById(`slot-${index}`);
            const list = slot.querySelector('ul');
            list.innerHTML = '';
            const chain = hashTable[index];

            for (const input of chain) {
                const listItem = document.createElement('li');
                listItem.className = 'bg-indigo-700 text-white px-1 rounded truncate';
                listItem.textContent = input;
                list.appendChild(listItem);
            }

            slot.querySelector('div').textContent = `#${index} (${chain.length})`;
        }

        // Setup event handlers when page loads
        window.onload = () => {
            initializeGrid();
            updateStatus();

            document.getElementById('startButton').addEventListener('click', animateHashing);
            document.getElementById('resolutionButton').addEventListener('click', animateResolution);
        };
    </script>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-extrabold text-indigo-400 mb-2">Pigeonhole Principle Hash Collision Demo</h1>
        <p class="text-gray-400 mb-6">
            <strong>Pigeonhole Principle:</strong> If the number of inputs ("pigeons") exceeds the number of hash slots ("pigeonholes"), collisions are mathematically inevitable.<br />
            This demo animates 150 inputs mapping into 100 hash slots, showing collisions and their resolution.
        </p>

        <!-- Control and status panel -->
        <section class="flex flex-col md:flex-row justify-between items-start md:items-center bg-gray-700 p-4 rounded-xl shadow-lg mb-6">
            <div class="mb-4 md:mb-0">
                <h2 id="statusTitle" class="text-xl font-bold text-white transition-colors duration-500">
                    Ready to Run
                </h2>
                <p id="statusText" class="text-sm text-gray-300 font-mono"></p>
            </div>
            <div class="flex gap-2">
                <button 
                    id="startButton" 
                    class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-full shadow-xl transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
                >
                    Start Collision Demonstration
                </button>
                <button 
                    id="resolutionButton" 
                    class="bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-3 px-6 rounded-full shadow-xl transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed"
                    disabled
                >
                    Start Resolution (Empty Chains)
                </button>
            </div>
        </section>

        <!-- Visualization grid -->
        <section id="hashGrid" class="grid grid-cols-5 sm:grid-cols-10 gap-2 md:gap-3 p-4 bg-gray-900 rounded-xl border border-indigo-900 shadow-2xl">
            <!-- Slots created dynamically -->
        </section>

        <!-- Explanation Blocks -->
        <section class="p-4 bg-gray-800 rounded-xl border border-gray-700 mt-6">
            <h3 class="text-lg font-semibold text-indigo-300 mb-2">Why Do Collisions Happen?</h3>
            <p class="text-gray-400">
                The <strong>pigeonhole principle</strong> establishes that if there are more inputs than hash outputs, some inputs must share the same slot, causing collisions. This isn't a flawâ€”it's a mathematical certainty.
            </p>
        </section>
        <section class="p-4 bg-gray-800 rounded-xl border border-gray-700 mt-4">
            <h3 class="text-lg font-semibold text-indigo-300 mb-2">How Collisions Are Resolved</h3>
            <p class="text-gray-400">
                This demo uses <strong>separate chaining</strong>: each hash slot holds a list of all inputs that map to it. This ensures no data is lost and supports efficient lookup despite collisions.
            </p>
        </section>
    </div>
</body>
</html>
