<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pigeonhole Principle Hash Demonstrator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar for hash list */
        .hash-slot-list::-webkit-scrollbar {
            width: 4px;
        }
        .hash-slot-list::-webkit-scrollbar-thumb {
            background-color: #4f46e5;
            border-radius: 2px;
        }
        .hash-slot-list::-webkit-scrollbar-track {
            background: #1f2937;
        }
        
        /* Font setup */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0f172a; /* Slate 900 */
            color: #f3f4f6; /* Gray 100 */
        }
    </style>
    <script>
        // --- Configuration ---
        const HASH_SPACE_SIZE = 100; // M: Pigeonholes
        const NUM_INPUTS = 150;      // N: Pigeons
        const INPUT_LENGTH = 8;
        const DELAY_MS = 50;         // Speed of animation

        // Data structure to hold the hash map (Pigeonholes)
        // Key: hash value, Value: Array of inputs (Pigeons)
        let hashTable = new Array(HASH_SPACE_SIZE).fill(0).map(() => []);

        // --- Core Hashing Logic (from Python script) ---
        function simpleNonCryptoHash(inputString, spaceSize) {
            let hashValue = 0;
            for (let i = 0; i < inputString.length; i++) {
                hashValue += inputString.charCodeAt(i);
            }
            return hashValue % spaceSize;
        }

        function generateRandomInput(length) {
            const characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let result = '';
            for (let i = 0; i < length; i++) {
                result += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return result;
        }

        // --- UI Initialization and Rendering ---

        let totalCollisions = 0;
        let inputsProcessed = 0;

        function initializeGrid() {
            const gridContainer = document.getElementById('hashGrid');
            gridContainer.innerHTML = '';
            
            for (let i = 0; i < HASH_SPACE_SIZE; i++) {
                const slot = document.createElement('div');
                slot.id = `slot-${i}`;
                slot.className = 'p-1 h-20 bg-gray-800 rounded-lg shadow-inner flex flex-col overflow-hidden transition-all duration-300 border border-gray-700';
                slot.innerHTML = `
                    <div class="text-xs font-mono text-gray-400">#${i} (${hashTable[i].length})</div>
                    <ul class="hash-slot-list text-xs font-mono mt-1 space-y-0.5 overflow-y-auto flex-grow"></ul>
                `;
                gridContainer.appendChild(slot);
            }
        }

        function updateStatus() {
            document.getElementById('statusText').textContent = 
                `Processed: ${inputsProcessed}/${NUM_INPUTS} | Unique Slots Used: ${hashTable.filter(arr => arr.length > 0).length} | Collisions: ${totalCollisions}`;
        }
        
        function updateSlotUI(hashIndex, newInput, isCollision) {
            const slot = document.getElementById(`slot-${hashIndex}`);
            const list = slot.querySelector('ul');

            // 1. Add the new input to the list (Demonstrates Chaining/Resolution)
            const listItem = document.createElement('li');
            listItem.className = 'bg-indigo-700 text-white px-1 rounded truncate opacity-0 transform translate-y-2 transition-all duration-300';
            listItem.textContent = newInput;
            list.appendChild(listItem);
            
            // Fade in effect
            setTimeout(() => {
                listItem.classList.remove('opacity-0', 'translate-y-2');
            }, 10);
            
            // 2. Update the counter
            slot.querySelector('div').textContent = `#${hashIndex} (${hashTable[hashIndex].length})`;

            // 3. Highlight the collision
            if (isCollision) {
                totalCollisions++;
                // Flash red for collision
                slot.classList.add('bg-red-700', 'border-red-500', 'ring-4', 'ring-red-500/50');
                setTimeout(() => {
                    slot.classList.remove('bg-red-700', 'border-red-500', 'ring-4', 'ring-red-500/50');
                    slot.classList.add('bg-indigo-800'); // Set collision color
                }, DELAY_MS * 2); 
            } else {
                // Highlight successful placement
                 slot.classList.add('bg-green-700', 'border-green-500', 'ring-4', 'ring-green-500/50');
                setTimeout(() => {
                    slot.classList.remove('bg-green-700', 'border-green-500', 'ring-4', 'ring-green-500/50');
                    slot.classList.add('bg-gray-800');
                }, DELAY_MS * 2);
            }

            if (hashTable[hashIndex].length > 1) {
                // Maintain the collision color for demonstration
                 slot.classList.remove('bg-gray-800');
                 slot.classList.add('bg-indigo-800');
            }
        }

        // --- Animation Loop ---

        async function animateHashing() {
            document.getElementById('startButton').disabled = true;
            inputsProcessed = 0;
            totalCollisions = 0;
            hashTable = new Array(HASH_SPACE_SIZE).fill(0).map(() => []);
            initializeGrid();
            updateStatus();

            for (let i = 0; i < NUM_INPUTS; i++) {
                const inputData = generateRandomInput(INPUT_LENGTH);
                const hashOutput = simpleNonCryptoHash(inputData, HASH_SPACE_SIZE);
                
                const isCollision = hashTable[hashOutput].length > 0;
                
                // Add the pigeon to the pigeonhole
                hashTable[hashOutput].push(inputData);
                inputsProcessed++;
                
                // Update the visualization
                updateSlotUI(hashOutput, inputData, isCollision);
                updateStatus();
                
                // Pause for animation effect
                await new Promise(resolve => setTimeout(resolve, DELAY_MS));
            }

            document.getElementById('statusTitle').textContent = "DEMONSTRATION COMPLETE!";
            document.getElementById('statusTitle').classList.add('text-yellow-400');
            document.getElementById('startButton').disabled = false;
        }

        // --- Main Setup ---
        window.onload = () => {
            initializeGrid();
            updateStatus();
            document.getElementById('startButton').addEventListener('click', animateHashing);
        };
    </script>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-extrabold text-indigo-400 mb-2">Cryptographic Collision Principle Visualizer</h1>
        <p class="text-gray-400 mb-6">
            Demonstrating the Pigeonhole Principle: When the number of inputs (Pigeons, $N={NUM_INPUTS}$) exceeds the number of output hash slots (Pigeonholes, $M={HASH_SPACE_SIZE}$), collisions are mathematically guaranteed.
        </p>

        <!-- Control and Status Panel -->
        <div class="flex flex-col md:flex-row justify-between items-start md:items-center bg-gray-700 p-4 rounded-xl shadow-lg mb-6">
            <div class="mb-4 md:mb-0">
                <h2 id="statusTitle" class="text-xl font-bold text-white transition-colors duration-500">
                    Ready to Run
                </h2>
                <p id="statusText" class="text-sm text-gray-300 font-mono"></p>
            </div>
            <button 
                id="startButton" 
                class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-3 px-6 rounded-full shadow-xl transition duration-300 ease-in-out transform hover:scale-105 disabled:opacity-50 disabled:cursor-not-allowed">
                Start Collision Demonstration
            </button>
        </div>

        <!-- Visualization Grid (Pigeonholes) -->
        <div id="hashGrid" class="grid grid-cols-5 sm:grid-cols-10 gap-2 md:gap-3 p-4 bg-gray-900 rounded-xl border border-indigo-900 shadow-2xl">
            <!-- Hash slots will be injected here by JavaScript -->
        </div>

        <!-- Explanation of Resolution -->
        <div class="mt-6 p-4 bg-gray-800 rounded-xl border border-gray-700">
            <h3 class="text-lg font-semibold text-indigo-300 mb-2">Collision Resolution (Chaining)</h3>
            <p class="text-gray-400">
                In real-world hash tables (like those used in database indices or key-value stores), when a collision occurs (two different inputs map to the same hash slot), the system doesn't crash. Instead, it uses **Chaining** (or Separate Chaining), which is the technique visually demonstrated above: 
                <span class="font-bold text-white">multiple inputs are stored as a linked list within the same hash slot (pigeonhole).</span> This is how the system "solves" the issue of having more data than available slots.
            </p>
        </div>
    </div>
</body>
</html>
